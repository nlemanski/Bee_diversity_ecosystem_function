## version of minfinder function to work with temporal analysis ##
# edited by NJL 3.11.21

# v is a vector that represents an ordering of the list elements 
# list[v] gives a reordering of list according to permutation v
minfinder = function(v) {  

	startvector = startvector[v]		# apply the newly permuted list of species generated by the genetic algorithm optimizer
	
	df_req = subset(func_outputB, rownames(func_outputB) %in% prereq_species)		# species needed because they occur at years that need all their species:
	df_extra = subset(func_outputB, !rownames(func_outputB) %in% prereq_species)	# all other species

	for (z in 1:(h*rmax)) {				# loop through all rounds or round-years in the current subset
	
		# Does the sitedate have enough aggregate function to meet the threshold with all its species??  
		# If not, we've already added everything we need, so skip to the next year.  If so, we need check what is already in the list of required species.
		
		if (sum(func_outputB[,z]) > func_level) { # added comma so it takes sum of all species in the year
						
			# Are there any species already in the list of required species?
			# If so, we need to evaluate it at this site.  If not, we need to add some new species.
			
			if (nrow(df_req) > 0) {
			
				# Do the species already in the list of required species satisfy this siteyear? If so, this siteyear is done, so skip to the next site.
				# if not, then we need to add some species:
				
				if (sum(df_req[,z]) < func_level) {
				
					# Add some species to the list of required species:
					
					# species available at this siteyear:
					df_extra_thissite = subset(df_extra, df_extra[,z]>0)
					
					# add species in the permuted order generated by the genetic algorithm optimizer:
					usethisorder = subset(startvector, startvector %in% rownames(df_extra_thissite))
					df_extra_thissite = df_extra_thissite[usethisorder,]
					
					# add the re-ordered available species to the already required ones:
					df_req_new = rbind(df_req,df_extra_thissite)
					
					# take cumulative sum and determine the ones needed to satisfy the threshold function level (cumulative sum needs to exceed threshold):
					df_req_new = cbind(df_req_new,cumsum = cumsum(df_req_new[,z]))
					df_req_new = rbind(subset(df_req_new, df_req_new[,"cumsum"]<func_level), df_req_new[nrow(subset(df_req_new, df_req_new[,"cumsum"]<func_level)) + 1, , drop=F])
					
					
					# redefine the list of required species to include the new required ones 
					df_req = subset(df_req_new, select = -cumsum)
					# redefine the list of unused available species to exclude the newly required ones 
					df_extra = subset(df_extra, !rownames(df_extra) %in% rownames(df_req_new))
					
				}	
				
			} else {	
				
					# Add some species to the list of required species:
					
					# species available at this siteyear:
					df_extra_thissite = subset(df_extra, df_extra[,z]>0)
					
					# add species in the permuted order generated by the genetic algorithm optimizer:
					usethisorder = subset(startvector, startvector %in% rownames(df_extra_thissite))
					df_extra_thissite = df_extra_thissite[usethisorder, , drop=F]  # added drop=F so it preserves type as matrix
					
					# add the re-ordered available species to the already required ones:
					df_req_new = rbind(df_req,df_extra_thissite)
					
					# take cumulative sum and determine the ones needed to satisfy the threshold function level (cumulative sum needs to exceed threshold):
					df_req_new = cbind(df_req_new,cumsum = cumsum(df_req_new[,z]))
					df_req_new = rbind(subset(df_req_new, df_req_new[,"cumsum"]<func_level), df_req_new[nrow(subset(df_req_new, df_req_new[,"cumsum"]<func_level)) + 1, , drop=F])
					
					# redefine the list of required species to include the new required ones 
					df_req = subset(df_req_new, select = -cumsum)
					# redefine the list of unused available species to exclude the newly required ones 
					df_extra = subset(df_extra, !rownames(df_extra) %in% rownames(df_req_new))
				
			}
		}
		
	}

	# save species required for this rep (uses global assignment outside this function):
	spreq_list <<- rownames(df_req)
	
	# convert to a value that can be maximized by the genetic algorithm.  The fitness function only works on maximums, not minimums.  Also, it only works with positive fitness values, so we use 1/x instead -x.
	# later, we will have to back-convert to get the minimum number of species.
	thismin = 1/nrow(df_req)
	
	return(thismin)
				
}



